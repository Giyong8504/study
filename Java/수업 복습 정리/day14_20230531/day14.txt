

3. 예외처리하기
try {
    // 예외가 발생할 가능성이 있는 코드

} catch (예외 객체){
   // 예외에 대한 적절한 처리
}
예외 발생시 문제 해결을 위한 가장 중요한 내용 - 오류 발생의 원인, 정보
Throwable : 예외의 정보를 확인하는 다양한 메서드가 정의
Throwable 
    - String.getMessage()  ****** 필수암기
    - void printStackTrace()  ******  필수암기

4. try-catch-finally문

FileNotFoundStream
  -FileNotFoundException(Exception 형태의 엄격한 예외)
  - 적절한 처리를 반드시 해야되는 예외가 정의

try {
    //예외가 발생할 가능성 있는 코드
    // 예외가 없으면 실행

} catch(예외객체) {
  //예외가 발생 시 예외처리

} finally {
  // 예외가 발생하든 안하든 항상 유입되는 구간
  // 함수 안에서 return 한 이후라도 항상 수행됩니다.

  //주로 하는 작업
     1) 자원해제
     2) 로그기록

}


5 try with resources 문
- finally문을 더 쉽게 해주는 문
- 자원해제를 자동으로 호출 - JDK 7에서 추가됨.

  try ( 자원해제가 필요한 객체;
        자원해제가 필요한 객체... ) {
  
  } catch( 예외 객체...) { // 생략가능

  }

  ...finally { //생략 가능

   }

AutoCloseable 인터페이스 구현 객체만 자원 해제 해준다.

AutoCloseable  얘가 기준.
이 구현 클래스일 때만 해제해줌.
로직이 끝나면 close() 만 호출.



6 예외처리 미루기
- 예외 처리를 메서드를 호출하는 쪽에서 처리하도록 전가
메서드 정의 부분 throws 처리를 전가시키는 예외 클래스 명시
- 메서드를 사용하는 쪽에서 통제 가능하게 하기 위해서
-  메서드에서 발생하는 예외를 처리하는 상황이 다양할 때



7다중예외처리

try {

     //예외가 발생할 ㅅ ㅜ있는 가능성이 있는 코드

} catch (예외 객체1 | 예외 객체2) {
     // 발생한 예외에 대한 처리

}

8 사용자의 예외 
- Exception, RuntimeException, 이를 상속 받는 하위 클래스 예외 상속
- 생성자를 정의

메서드를 사용하는 쪽에서 예외 처리를 다양하게 할 때,
메서드 쪽에 예외 전가 - throws

 try-catch-finally


finally
- 예외가 발생하든 안하든 항상 실행되는 코드
- 자원해제
- 로그기록



자원해제 -> try with resources 문 (자원해제 특화)
기준 1) AutoCloseable 인터페이스의 구현체
      2) close() 메서드 자동 호출 (되면 오버라이드 해서 내용정의 해야함)


로그인
-아이디 일치하지 않을 때 예외 발생
-비밀번호가 일치하지 않을 때 예외 발생



예외 처리시 예외가 대부분 생성자로 정의되어 있어서 
생성자만 잘 이용하면 된다.
예외 클래스를 상속받고 생성자만 정의하면 된다.


super <--- 상위클래스의 생성자


====================================
============================

컴파일러가 자동추가해 주는 소스
1. 기본 생성자 
2. 생성자의 첫번째 줄에 - super()
3. 인터페이스 메서드 - public abstract
4. 인터페이스 변수 -> public static final : 정적 상수
5. 지역 내부클래스 지역변수 -> 상수화 final
6. 패키지명 바로 아래줄 import java.lang.*; 추가됨.











